"""
A production facility needs an iterable object to keep track product assembly times.
A class called "KeyboardProductionTimes" that will store the information needs to be created.
Each keyboard will have a string serial number "KBXXXXXX" and timedelta (or int) for production time
Iterating objects created with KeyboardProductionTimes will return all keyboards that had production
time greater than 2000s
1) 40p: Definition
    a) 10p: Basic class structure of KeyboardProductionTimes
    b) 10p: Basic class structure of iterator
    c) 10p: Method to add produced keyboards with serial and time
    d) 10p: Method that returns average keyboard production time
2) 40p: Execution:
    a) 10p: Create instance of KeyboardProductionTimes
    b) 10p: Call method to add keyboard <add_keyboard(serial, <timedelta | int>)>
        - KB023871, 3210s
        - KB023873, 1890s
        - KB023875, 1982s
    c) 10p: Call method to return average production time <average_production_time()>
    d) 10p: Iterate the created object and write each keyboard serial with production
            time greater then 2000s in a file on a new line
3) 20p: Documenting:
   a) 5p: type hints for arguments
   b) 5p: module documentation
   c) 5p: class documentation for all classes
   d) 5p: method documentation for all methods
"""

class KeyboardProductionTimes:
    '''
    this is a docstring
    '''
    
    def __init__(self):
        self.depozit_keyboards={}
    
    def __iter__(self):
        return KeyboardProductionTimesIter(self.depozit_keyboards)
    
    def add_keyboard(self,serial:str,time:int):
        '''
        :param serial: serial number of keyboards
        :param time: production time 
        '''
        self.depozit_keyboards.update({serial:time})
    
    def average_production_time(self,serial:str=None,time:int=None):
        for time in self.depozit_keyboards.update().items():
            time+=time
            
        
class KeyboardProductionTimesIter:
    
    def __iter__(self):
        return self
        
    def __next__(self):
        for serial,timp in depozit_keyboards.copy().items():
            if timp>2000:
                del self.depozit_keyboards[serial]
                return serial
            else:
                del self.depozit_keyboards[serial]
        else:
            raise StopIteration
    
    def __init__(self,depozit_keyboards:dict):
        self.depozit_keyboards=depozit_keyboards



k= KeyboardProductionTimes()
k.add_keyboard('KB023871',3210)
k.add_keyboard('KB023875',1982)
k.add_keyboard('KB023873',1890)
print(k.depozit_keyboards)



#with open('Out.Log','x') as file:
   # for user in k:
    #    file.write(user)
